From 5081670f17f6aa86be76f18c5852adec6e021080 Mon Sep 17 00:00:00 2001
From: He Junyan <junyan.he@intel.com>
Date: Tue, 4 Apr 2023 16:26:46 +0800
Subject: [PATCH] va: encoder: Add preferred_output_delay property to improve
 performance

---
 .../gst-libs/gst/va/vasurfaceimage.c          | 20 ++++++
 .../gst-libs/gst/va/vasurfaceimage.h          |  4 ++
 .../gst-plugins-bad/sys/va/gstvaav1enc.c      | 52 +++++++-------
 .../gst-plugins-bad/sys/va/gstvabaseenc.c     | 69 ++++++++++++++++++-
 .../gst-plugins-bad/sys/va/gstvabaseenc.h     | 24 +++++++
 .../gst-plugins-bad/sys/va/gstvah264enc.c     | 61 ++++++++--------
 .../gst-plugins-bad/sys/va/gstvah265enc.c     | 60 ++++++++--------
 .../gst-plugins-bad/sys/va/gstvajpegenc.c     | 36 +++++-----
 .../gst-plugins-bad/sys/va/gstvavp9enc.c      | 49 +++++++------
 9 files changed, 243 insertions(+), 132 deletions(-)

diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.c b/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.c
index d6d8f4985a..e98fb25832 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.c
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.c
@@ -293,6 +293,26 @@ va_check_surface (GstVaDisplay * display, VASurfaceID surface)
   return (status == VA_STATUS_SUCCESS);
 }
 
+gboolean
+va_check_surface_status (GstVaDisplay * display, VASurfaceID surface,
+    VASurfaceStatus surface_status)
+{
+  VADisplay dpy = gst_va_display_get_va_dpy (display);
+  VAStatus status;
+  VASurfaceStatus state;
+
+  status = vaQuerySurfaceStatus (dpy, surface, &state);
+
+  if (status != VA_STATUS_SUCCESS) {
+    GST_ERROR ("vaQuerySurfaceStatus: %s", vaErrorStr (status));
+    return FALSE;
+  }
+
+  GST_LOG ("surface %#x status %d", surface, state);
+
+  return ((state & surface_status) == surface_status);
+}
+
 gboolean
 va_copy_surface (GstVaDisplay * display, VASurfaceID dst, VASurfaceID src)
 {
diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.h b/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.h
index 18f88f757a..d2b139b998 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.h
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/va/vasurfaceimage.h
@@ -49,6 +49,10 @@ gboolean              va_sync_surface                     (GstVaDisplay * displa
 GST_VA_API
 gboolean              va_check_surface                    (GstVaDisplay * display,
                                                            VASurfaceID surface);
+GST_VA_API
+gboolean              va_check_surface_status             (GstVaDisplay * display,
+                                                           VASurfaceID surface,
+                                                           VASurfaceStatus surface_status);
 
 gboolean              va_copy_surface                     (GstVaDisplay * display,
                                                            VASurfaceID dst,
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvaav1enc.c b/subprojects/gst-plugins-bad/sys/va/gstvaav1enc.c
index eadf0ffbb5..f18dbea1e9 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvaav1enc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvaav1enc.c
@@ -156,7 +156,7 @@ struct _GstVaAV1Ref
 
 struct _GstVaAV1EncFrame
 {
-  GstVaEncodePicture *picture;
+  GstVaEncFrame base;
   GstAV1FrameType type;
   guint8 temporal_id;
   guint8 spatial_id;
@@ -460,11 +460,7 @@ _av1_helper_msb (guint n)
 static inline GstVaAV1EncFrame *
 _enc_frame (GstVideoCodecFrame * frame)
 {
-  GstVaAV1EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
-
-  g_assert (enc_frame);
-
-  return enc_frame;
+  return gst_va_get_enc_frame (frame);
 }
 
 #ifndef GST_DISABLE_GST_DEBUG
@@ -498,7 +494,7 @@ gst_va_av1_enc_frame_new (void)
   frame->type = FRAME_TYPE_INVALID;
   frame->temporal_id = 0;
   frame->spatial_id = 0;
-  frame->picture = NULL;
+  frame->base.picture = NULL;
   frame->total_frame_count = 0;
   frame->pyramid_level = 0;
   frame->flags = 0;
@@ -516,7 +512,7 @@ gst_va_av1_enc_frame_free (gpointer pframe)
 {
   GstVaAV1EncFrame *frame = pframe;
 
-  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_clear_pointer (&frame->base.picture, gst_va_encode_picture_free);
   g_slice_free (GstVaAV1EncFrame, frame);
 }
 
@@ -527,7 +523,7 @@ gst_va_av1_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 
   frame_in = gst_va_av1_enc_frame_new ();
   frame_in->total_frame_count = base->input_frame_count++;
-  gst_video_codec_frame_set_user_data (frame, frame_in,
+  gst_va_set_enc_frame (frame, (GstVaEncFrame *) frame_in,
       gst_va_av1_enc_frame_free);
 
   return TRUE;
@@ -2927,7 +2923,7 @@ _av1_add_sequence_header (GstVaAV1Enc * self, GstVaAV1EncFrame * frame,
 
   *size_offset += size;
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSequence, packed_sps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add packed sequence header.");
     return FALSE;
@@ -3103,8 +3099,8 @@ _av1_fill_frame_param (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
     .frame_width_minus_1 = base->width - 1,
     .frame_height_minus_1 = base->height - 1,
     .reconstructed_frame =
-        gst_va_encode_picture_get_reconstruct_surface (va_frame->picture),
-    .coded_buf = va_frame->picture->coded_buffer,
+        gst_va_encode_picture_get_reconstruct_surface (va_frame->base.picture),
+    .coded_buf = va_frame->base.picture->coded_buffer,
     .primary_ref_frame = primary_ref_frame,
     .order_hint = va_frame->order_hint,
     .refresh_frame_flags = refresh_frame_flags,
@@ -3226,7 +3222,7 @@ _av1_fill_frame_param (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
 
       pic_param->reference_frames[i] =
           gst_va_encode_picture_get_reconstruct_surface
-          (_enc_frame (self->gop.ref_list[i])->picture);
+          (_enc_frame (self->gop.ref_list[i])->base.picture);
     }
 
     for (i = 0; i < 7; i++) {
@@ -3533,7 +3529,7 @@ _av1_add_tile_group_param (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
     tile_group_param.tg_end = (index + 1) * div - 1;
   }
 
-  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->base.picture,
           VAEncSliceParameterBufferType, &tile_group_param,
           sizeof (VAEncTileGroupBufferAV1))) {
     GST_ERROR_OBJECT (self, "Failed to add one tile group parameter");
@@ -3605,13 +3601,13 @@ _av1_encode_one_frame (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
     pic_param.size_in_bits_frame_hdr_obu = frame_hdr_size * 8;
   }
 
-  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->base.picture,
           VAEncPictureParameterBufferType, &pic_param, sizeof (pic_param))) {
     GST_ERROR_OBJECT (self, "Failed to create the frame parameter");
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, va_frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, va_frame->base.picture,
           VAEncPackedHeaderPicture, packed_frame_hdr, frame_hdr_size * 8,
           FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed frame header");
@@ -3625,7 +3621,7 @@ _av1_encode_one_frame (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
     }
   }
 
-  if (!gst_va_encoder_encode (base->encoder, va_frame->picture)) {
+  if (!gst_va_encoder_encode (base->encoder, va_frame->base.picture)) {
     GST_ERROR_OBJECT (self, "Encode frame error");
     return FALSE;
   }
@@ -3682,7 +3678,7 @@ _av1_add_td (GstVaAV1Enc * self, GstVaAV1EncFrame * frame, guint * size_offset)
 
   *size_offset += td_data_size;
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderRawData, td_data, td_data_size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the temporal delimiter.");
     return FALSE;
@@ -3713,8 +3709,8 @@ gst_va_av1_enc_encode_frame (GstVaBaseEnc * base,
   } else {
     guint size_offset = 0;
 
-    g_assert (va_frame->picture == NULL);
-    va_frame->picture = gst_va_encode_picture_new (base->encoder,
+    g_assert (va_frame->base.picture == NULL);
+    va_frame->base.picture = gst_va_encode_picture_new (base->encoder,
         gst_frame->input_buffer);
 
     _av1_find_ref_to_update (base, gst_frame);
@@ -3726,25 +3722,27 @@ gst_va_av1_enc_encode_frame (GstVaBaseEnc * base,
 
     /* Repeat the sequence for each key. */
     if (va_frame->frame_num == 0) {
-      if (!gst_va_base_enc_add_rate_control_parameter (base, va_frame->picture,
+      if (!gst_va_base_enc_add_rate_control_parameter (base,
+              va_frame->base.picture,
               self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
               self->rc.target_percentage, self->rc.base_qindex,
               self->rc.min_qindex, self->rc.max_qindex, self->rc.mbbrc))
         return FALSE;
 
-      if (!gst_va_base_enc_add_quality_level_parameter (base, va_frame->picture,
-              self->rc.target_usage))
+      if (!gst_va_base_enc_add_quality_level_parameter (base,
+              va_frame->base.picture, self->rc.target_usage))
         return FALSE;
 
-      if (!gst_va_base_enc_add_frame_rate_parameter (base, va_frame->picture))
+      if (!gst_va_base_enc_add_frame_rate_parameter (base,
+              va_frame->base.picture))
         return FALSE;
 
-      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->picture,
+      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->base.picture,
               self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
         return FALSE;
 
       _av1_fill_sequence_param (self, &seq_param);
-      if (!_av1_add_sequence_param (self, va_frame->picture, &seq_param))
+      if (!_av1_add_sequence_param (self, va_frame->base.picture, &seq_param))
         return FALSE;
 
       _av1_fill_sequence_header (self, &seq_param);
@@ -3818,7 +3816,7 @@ gst_va_av1_enc_prepare_output (GstVaBaseEnc * base,
 
     *complete = TRUE;
   } else {
-    buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+    buf = gst_va_base_enc_create_output_buffer (base, frame_enc->base.picture);
     if (!buf) {
       GST_ERROR_OBJECT (base, "Failed to create output buffer");
       return FALSE;
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.c b/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.c
index f15cb2d612..7a73843216 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.c
@@ -39,6 +39,7 @@ struct _GstVaBaseEncPrivate
 enum
 {
   PROP_DEVICE_PATH = 1,
+  PROP_PREFERRED_OUTPUT_DELAY,
   N_PROPERTIES
 };
 
@@ -69,6 +70,7 @@ gst_va_base_enc_reset_state_default (GstVaBaseEnc * base)
   base->profile = VAProfileNone;
   base->rt_format = 0;
   base->codedbuf_size = 0;
+  base->preferred_output_delay = base->prop_preferred_output_delay;
   g_atomic_int_set (&base->reconf, FALSE);
 }
 
@@ -561,6 +563,30 @@ _push_out_one_buffer (GstVaBaseEnc * base)
   return ret;
 }
 
+static gboolean
+_output_buffer_is_ready (GstVaBaseEnc * base)
+{
+  GstVideoCodecFrame *frame_out;
+  GstVaEncFrame *frame_enc;
+  VASurfaceID surface;
+  gboolean ret;
+
+  frame_out = g_queue_peek_head (&base->output_list);
+  if (frame_out == NULL)
+    return FALSE;
+
+  frame_enc = gst_va_get_enc_frame (frame_out);
+
+  surface = gst_va_encode_picture_get_raw_surface (frame_enc->picture);
+
+  ret = va_check_surface_status (base->display, surface, VASurfaceReady);
+
+  GST_LOG_OBJECT (base, "Output of system_frame_number %d is %s",
+      frame_out->system_frame_number, ret ? "ready" : "not ready");
+
+  return ret;
+}
+
 static GstFlowReturn
 gst_va_base_enc_drain (GstVideoEncoder * venc)
 {
@@ -710,7 +736,11 @@ gst_va_base_enc_handle_frame (GstVideoEncoder * venc,
     if (ret != GST_FLOW_OK)
       goto error_encode;
 
-    while (g_queue_get_length (&base->output_list) > 0)
+    while (g_queue_get_length (&base->output_list) >
+        base->preferred_output_delay)
+      ret = _push_out_one_buffer (base);
+
+    while (_output_buffer_is_ready (base))
       ret = _push_out_one_buffer (base);
 
     frame_encode = NULL;
@@ -892,6 +922,25 @@ gst_va_base_enc_set_context (GstElement * element, GstContext * context)
   GST_ELEMENT_CLASS (parent_class)->set_context (element, context);
 }
 
+static void
+gst_va_base_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (object);
+
+  GST_OBJECT_LOCK (base);
+  switch (prop_id) {
+    case PROP_PREFERRED_OUTPUT_DELAY:
+      base->prop_preferred_output_delay = g_value_get_uint (value);
+      g_atomic_int_set (&base->reconf, TRUE);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+
+  GST_OBJECT_UNLOCK (base);
+}
+
 static void
 gst_va_base_enc_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec)
@@ -910,6 +959,9 @@ gst_va_base_enc_get_property (GObject * object, guint prop_id,
 
       break;
     }
+    case PROP_PREFERRED_OUTPUT_DELAY:
+      g_value_set_uint (value, base->prop_preferred_output_delay);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
   }
@@ -942,6 +994,7 @@ gst_va_base_enc_class_init (GstVaBaseEncClass * klass)
   GstVideoEncoderClass *encoder_class = GST_VIDEO_ENCODER_CLASS (klass);
 
   gobject_class->get_property = gst_va_base_enc_get_property;
+  gobject_class->set_property = gst_va_base_enc_set_property;
   gobject_class->dispose = gst_va_base_enc_dispose;
 
   element_class->set_context = GST_DEBUG_FUNCPTR (gst_va_base_enc_set_context);
@@ -972,6 +1025,20 @@ gst_va_base_enc_class_init (GstVaBaseEncClass * klass)
       "Device Path", GST_VA_DEVICE_PATH_PROP_DESC, NULL,
       GST_PARAM_DOC_SHOW_DEFAULT | G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
+  /**
+   * GstVaBaseEnc:preferred-output-delay:
+   *
+   * The user preferred output delay to get better throughput performance.
+   * The higher delay may get better HW performance, but increase the
+   * encoder and pipeline latency.
+   */
+  properties[PROP_PREFERRED_OUTPUT_DELAY] = g_param_spec_uint
+      ("preferred-output-delay", "Preferred Output Delay",
+      "The user preferred output delay to get "
+      "better throughput performance", 0, 8, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+      G_PARAM_CONSTRUCT | GST_PARAM_MUTABLE_PLAYING);
+
   g_object_class_install_properties (gobject_class, N_PROPERTIES, properties);
 
   gst_type_mark_as_plugin_api (GST_TYPE_VA_BASE_ENC, 0);
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.h b/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.h
index 0007a13e29..975476c9b6 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.h
+++ b/subprojects/gst-plugins-bad/sys/va/gstvabaseenc.h
@@ -35,10 +35,16 @@ G_BEGIN_DECLS
 
 #define GST_VA_BASE_ENC_ENTRYPOINT(obj) (GST_VA_BASE_ENC_GET_CLASS(obj)->entrypoint)
 
+typedef struct _GstVaEncFrame GstVaEncFrame;
 typedef struct _GstVaBaseEnc GstVaBaseEnc;
 typedef struct _GstVaBaseEncClass GstVaBaseEncClass;
 typedef struct _GstVaBaseEncPrivate GstVaBaseEncPrivate;
 
+struct _GstVaEncFrame
+{
+  GstVaEncodePicture *picture;
+};
+
 struct _GstVaBaseEnc
 {
   GstVideoEncoder parent_instance;
@@ -63,6 +69,8 @@ struct _GstVaBaseEnc
   GQueue reorder_list;
   GQueue ref_list;
   GQueue output_list;
+  guint preferred_output_delay;
+  guint prop_preferred_output_delay;
 
   GstVideoCodecState *input_state;
 
@@ -148,6 +156,22 @@ void                  gst_va_base_enc_update_property_bool (GstVaBaseEnc * base,
                                                             gboolean new_val,
                                                             GParamSpec * pspec);
 
+inline gpointer
+gst_va_get_enc_frame (GstVideoCodecFrame * frame)
+{
+  GstVaEncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
+  g_assert (enc_frame);
+
+  return enc_frame;
+}
+
+inline void
+gst_va_set_enc_frame (GstVideoCodecFrame * frame,
+    GstVaEncFrame * frame_in, GDestroyNotify notify)
+{
+  gst_video_codec_frame_set_user_data (frame, frame_in, notify);
+}
+
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstVaBaseEnc, gst_object_unref)
 
 G_END_DECLS
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvah264enc.c b/subprojects/gst-plugins-bad/sys/va/gstvah264enc.c
index 60b6b23686..594082557c 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvah264enc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvah264enc.c
@@ -260,7 +260,7 @@ struct _GstVaH264Enc
 
 struct _GstVaH264EncFrame
 {
-  GstVaEncodePicture *picture;
+  GstVaEncFrame base;
   GstH264SliceType type;
   gboolean is_ref;
   guint pyramid_level;
@@ -379,7 +379,7 @@ gst_va_enc_frame_new (void)
   frame = g_new (GstVaH264EncFrame, 1);
   frame->frame_num = 0;
   frame->unused_for_reference_pic_num = -1;
-  frame->picture = NULL;
+  frame->base.picture = NULL;
   frame->total_frame_count = 0;
   frame->last_frame = FALSE;
 
@@ -390,16 +390,14 @@ static void
 gst_va_enc_frame_free (gpointer pframe)
 {
   GstVaH264EncFrame *frame = pframe;
-  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_clear_pointer (&frame->base.picture, gst_va_encode_picture_free);
   g_free (frame);
 }
 
 static inline GstVaH264EncFrame *
 _enc_frame (GstVideoCodecFrame * frame)
 {
-  GstVaH264EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
-  g_assert (enc_frame);
-  return enc_frame;
+  return gst_va_get_enc_frame (frame);
 }
 
 /* Normalizes bitrate (and CPB size) for HRD conformance */
@@ -2106,7 +2104,7 @@ _add_sequence_header (GstVaH264Enc * self, GstVaH264EncFrame * frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSequence, packed_sps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed sequence header");
     return FALSE;
@@ -2233,10 +2231,10 @@ _fill_picture_parameter (GstVaH264Enc * self, GstVaH264EncFrame * frame,
   *pic_param = (VAEncPictureParameterBufferH264) {
     .CurrPic = {
       .picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (frame->picture),
+          gst_va_encode_picture_get_reconstruct_surface (frame->base.picture),
       .TopFieldOrderCnt = frame->poc,
     },
-    .coded_buf = frame->picture->coded_buffer,
+    .coded_buf = frame->base.picture->coded_buffer,
     /* Only support one sps and pps now. */
     .pic_parameter_set_id = 0,
     .seq_parameter_set_id = 0,
@@ -2285,7 +2283,7 @@ _fill_picture_parameter (GstVaH264Enc * self, GstVaH264EncFrame * frame,
       f = _enc_frame (g_queue_peek_nth (&base->ref_list, i));
 
       pic_param->ReferenceFrames[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (f->picture);
+          gst_va_encode_picture_get_reconstruct_surface (f->base.picture);
       pic_param->ReferenceFrames[i].TopFieldOrderCnt = f->poc;
       pic_param->ReferenceFrames[i].flags =
           VA_PICTURE_H264_SHORT_TERM_REFERENCE;
@@ -2304,7 +2302,7 @@ _add_picture_parameter (GstVaH264Enc * self, GstVaH264EncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncPictureParameterBufferType, pic_param,
           sizeof (VAEncPictureParameterBufferH264))) {
     GST_ERROR_OBJECT (self, "Failed to create the picture parameter");
@@ -2368,7 +2366,7 @@ _add_picture_header (GstVaH264Enc * self, GstVaH264EncFrame * frame,
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderPicture, packed_pps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed picture header");
     return FALSE;
@@ -2446,7 +2444,8 @@ _add_one_slice (GstVaH264Enc * self, GstVaH264EncFrame * frame,
   if (frame->type != GST_H264_I_SLICE) {
     for (; i < list0_num; i++) {
       slice->RefPicList0[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (list0[i]->picture);
+          gst_va_encode_picture_get_reconstruct_surface
+          (list0[i]->base.picture);
       slice->RefPicList0[i].TopFieldOrderCnt = list0[i]->poc;
       slice->RefPicList0[i].flags |= VA_PICTURE_H264_SHORT_TERM_REFERENCE;
       slice->RefPicList0[i].frame_idx = list0[i]->frame_num;
@@ -2461,7 +2460,8 @@ _add_one_slice (GstVaH264Enc * self, GstVaH264EncFrame * frame,
   if (frame->type == GST_H264_B_SLICE) {
     for (; i < list1_num; i++) {
       slice->RefPicList1[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (list1[i]->picture);
+          gst_va_encode_picture_get_reconstruct_surface
+          (list1[i]->base.picture);
       slice->RefPicList1[i].TopFieldOrderCnt = list1[i]->poc;
       slice->RefPicList1[i].flags |= VA_PICTURE_H264_SHORT_TERM_REFERENCE;
       slice->RefPicList1[i].frame_idx = list1[i]->frame_num;
@@ -2472,7 +2472,7 @@ _add_one_slice (GstVaH264Enc * self, GstVaH264EncFrame * frame,
     slice->RefPicList1[i].flags = VA_PICTURE_H264_INVALID;
   }
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncSliceParameterBufferType, slice,
           sizeof (VAEncSliceParameterBufferH264))) {
     GST_ERROR_OBJECT (self, "Failed to create the slice parameter");
@@ -2703,7 +2703,7 @@ _add_slice_header (GstVaH264Enc * self, GstVaH264EncFrame * frame,
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSlice, packed_slice_hdr, size * 8 + trail_bits,
           FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed slice header");
@@ -2743,7 +2743,7 @@ _add_aud (GstVaH264Enc * self, GstVaH264EncFrame * frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderRawData, aud_data, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the AUD");
     return FALSE;
@@ -2858,7 +2858,7 @@ _add_sei_cc (GstVaH264Enc * self, GstVideoCodecFrame * gst_frame)
     goto out;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderRawData, packed_sei, sei_size * 8, FALSE)) {
     GST_WARNING_OBJECT (self, "Failed to add SEI CC data");
     goto out;
@@ -2895,24 +2895,24 @@ _encode_one_frame (GstVaH264Enc * self, GstVideoCodecFrame * gst_frame)
   if (frame->poc == 0) {
     VAEncSequenceParameterBufferH264 sequence;
 
-    if (!gst_va_base_enc_add_rate_control_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_rate_control_parameter (base, frame->base.picture,
             self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
             self->rc.target_percentage, self->rc.qp_i, self->rc.min_qp,
             self->rc.max_qp, self->rc.mbbrc))
       return FALSE;
 
-    if (!gst_va_base_enc_add_quality_level_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_quality_level_parameter (base, frame->base.picture,
             self->rc.target_usage))
       return FALSE;
 
-    if (!gst_va_base_enc_add_frame_rate_parameter (base, frame->picture))
+    if (!gst_va_base_enc_add_frame_rate_parameter (base, frame->base.picture))
       return FALSE;
 
-    if (!gst_va_base_enc_add_hrd_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_hrd_parameter (base, frame->base.picture,
             self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
       return FALSE;
 
-    if (!gst_va_base_enc_add_trellis_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_trellis_parameter (base, frame->base.picture,
             self->use_trellis))
       return FALSE;
 
@@ -2920,7 +2920,7 @@ _encode_one_frame (GstVaH264Enc * self, GstVideoCodecFrame * gst_frame)
     if (!_fill_sps (self, &sequence))
       return FALSE;
 
-    if (!_add_sequence_parameter (self, frame->picture, &sequence))
+    if (!_add_sequence_parameter (self, frame->base.picture, &sequence))
       return FALSE;
 
     if ((self->packed_headers & VA_ENC_PACKED_HEADER_SEQUENCE)
@@ -3017,7 +3017,7 @@ _encode_one_frame (GstVaH264Enc * self, GstVideoCodecFrame * gst_frame)
     slice_start_mb += slice_mbs;
   }
 
-  if (!gst_va_encoder_encode (base->encoder, frame->picture)) {
+  if (!gst_va_encoder_encode (base->encoder, frame->base.picture)) {
     GST_ERROR_OBJECT (self, "Encode frame error");
     return FALSE;
   }
@@ -3056,7 +3056,7 @@ gst_va_h264_enc_prepare_output (GstVaBaseEnc * base,
   base->output_frame_count++;
   frame->duration = base->frame_duration;
 
-  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->base.picture);
   if (!buf) {
     GST_ERROR_OBJECT (base, "Failed to create output buffer");
     return FALSE;
@@ -3153,11 +3153,11 @@ gst_va_h264_enc_encode_frame (GstVaBaseEnc * base,
   frame = _enc_frame (gst_frame);
   frame->last_frame = is_last;
 
-  g_assert (frame->picture == NULL);
-  frame->picture = gst_va_encode_picture_new (base->encoder,
+  g_assert (frame->base.picture == NULL);
+  frame->base.picture = gst_va_encode_picture_new (base->encoder,
       gst_frame->input_buffer);
 
-  if (!frame->picture) {
+  if (!frame->base.picture) {
     GST_ERROR_OBJECT (self, "Failed to create the encode picture");
     return GST_FLOW_ERROR;
   }
@@ -3197,7 +3197,8 @@ gst_va_h264_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 
   frame_in = gst_va_enc_frame_new ();
   frame_in->total_frame_count = base->input_frame_count++;
-  gst_video_codec_frame_set_user_data (frame, frame_in, gst_va_enc_frame_free);
+  gst_va_set_enc_frame (frame, (GstVaEncFrame *) frame_in,
+      gst_va_enc_frame_free);
 
   return TRUE;
 }
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvah265enc.c b/subprojects/gst-plugins-bad/sys/va/gstvah265enc.c
index 470f531f2e..32d0265bf2 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvah265enc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvah265enc.c
@@ -339,7 +339,7 @@ struct _GstVaH265Enc
 
 struct _GstVaH265EncFrame
 {
-  GstVaEncodePicture *picture;
+  GstVaEncFrame base;
   GstH265SliceType type;
   gboolean is_ref;
   guint pyramid_level;
@@ -451,7 +451,7 @@ gst_va_h265_enc_frame_new (void)
 
   frame = g_new (GstVaH265EncFrame, 1);
   frame->last_frame = FALSE;
-  frame->picture = NULL;
+  frame->base.picture = NULL;
   frame->total_frame_count = 0;
 
   return frame;
@@ -461,16 +461,14 @@ static void
 gst_va_h265_enc_frame_free (gpointer pframe)
 {
   GstVaH265EncFrame *frame = pframe;
-  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_clear_pointer (&frame->base.picture, gst_va_encode_picture_free);
   g_free (frame);
 }
 
 static inline GstVaH265EncFrame *
 _enc_frame (GstVideoCodecFrame * frame)
 {
-  GstVaH265EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
-  g_assert (enc_frame);
-  return enc_frame;
+  return gst_va_get_enc_frame (frame);
 }
 
 static inline gboolean
@@ -1169,7 +1167,7 @@ _h265_add_vps_header (GstVaH265Enc * self, GstVaH265EncFrame * frame)
 
   /* VPS does not have its own packed header define, just reuse
      VAEncPackedHeaderSequence */
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSequence, packed_vps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add packed VPS header.");
     return FALSE;
@@ -1196,7 +1194,7 @@ _h265_add_sps_header (GstVaH265Enc * self, GstVaH265EncFrame * frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSequence, packed_sps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add packed SPS header.");
     return FALSE;
@@ -1222,7 +1220,7 @@ _h265_add_pps_header (GstVaH265Enc * self, GstVaH265EncFrame * frame,
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderPicture, packed_pps, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed picture header");
     return FALSE;
@@ -1249,7 +1247,7 @@ _h265_add_slice_header (GstVaH265Enc * self, GstVaH265EncFrame * frame,
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderSlice, packed_slice_hdr, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the packed slice header");
     return FALSE;
@@ -1288,7 +1286,7 @@ _h265_add_aud (GstVaH265Enc * self, GstVaH265EncFrame * frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderRawData, aud_data, size * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add the AUD");
     return FALSE;
@@ -1501,11 +1499,11 @@ _h265_fill_picture_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
 
   *pic_param = (VAEncPictureParameterBufferHEVC) {
     .decoded_curr_pic.picture_id =
-        gst_va_encode_picture_get_reconstruct_surface (frame->picture),
+        gst_va_encode_picture_get_reconstruct_surface (frame->base.picture),
     .decoded_curr_pic.pic_order_cnt = frame->poc,
     .decoded_curr_pic.flags = 0,
 
-    .coded_buf = frame->picture->coded_buffer,
+    .coded_buf = frame->base.picture->coded_buffer,
     .last_picture = frame->last_frame,
     .pic_init_qp = self->rc.qp_i,
     .diff_cu_qp_delta_depth = self->features.diff_cu_qp_delta_depth,
@@ -1577,7 +1575,7 @@ _h265_fill_picture_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
       f = _enc_frame (g_queue_peek_nth (&base->ref_list, i));
 
       pic_param->reference_frames[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (f->picture);
+          gst_va_encode_picture_get_reconstruct_surface (f->base.picture);
       pic_param->reference_frames[i].pic_order_cnt = f->poc;
       pic_param->reference_frames[i].flags = 0;
     }
@@ -1747,7 +1745,8 @@ _h265_fill_slice_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
   if (frame_type != GST_H265_I_SLICE) {
     for (; i < list0_num; i++) {
       slice->ref_pic_list0[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (list0[i]->picture);
+          gst_va_encode_picture_get_reconstruct_surface
+          (list0[i]->base.picture);
       slice->ref_pic_list0[i].pic_order_cnt = list0[i]->poc;
     }
   }
@@ -1760,7 +1759,8 @@ _h265_fill_slice_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
   if (frame_type == GST_H265_B_SLICE) {
     for (; i < list1_num; i++) {
       slice->ref_pic_list1[i].picture_id =
-          gst_va_encode_picture_get_reconstruct_surface (list1[i]->picture);
+          gst_va_encode_picture_get_reconstruct_surface
+          (list1[i]->base.picture);
       slice->ref_pic_list1[i].pic_order_cnt = list1[i]->poc;
     }
   }
@@ -1778,7 +1778,7 @@ _h265_add_sequence_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncSequenceParameterBufferType, sequence, sizeof (*sequence))) {
     GST_ERROR_OBJECT (self, "Failed to create the sequence parameter");
     return FALSE;
@@ -1793,7 +1793,7 @@ _h265_add_picture_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncPictureParameterBufferType, pic_param,
           sizeof (VAEncPictureParameterBufferHEVC))) {
     GST_ERROR_OBJECT (self, "Failed to create the picture parameter");
@@ -1809,7 +1809,7 @@ _h265_add_slice_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncSliceParameterBufferType, slice,
           sizeof (VAEncSliceParameterBufferHEVC))) {
     GST_ERROR_OBJECT (self, "Failed to add the slice parameter");
@@ -1897,24 +1897,24 @@ _h265_encode_one_frame (GstVaH265Enc * self, GstVideoCodecFrame * gst_frame)
   if (frame->poc == 0) {
     VAEncSequenceParameterBufferHEVC sequence;
 
-    if (!gst_va_base_enc_add_rate_control_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_rate_control_parameter (base, frame->base.picture,
             self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
             self->rc.target_percentage, self->rc.qp_i, self->rc.min_qp,
             self->rc.max_qp, self->rc.mbbrc))
       return FALSE;
 
-    if (!gst_va_base_enc_add_quality_level_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_quality_level_parameter (base, frame->base.picture,
             self->rc.target_usage))
       return FALSE;
 
-    if (!gst_va_base_enc_add_frame_rate_parameter (base, frame->picture))
+    if (!gst_va_base_enc_add_frame_rate_parameter (base, frame->base.picture))
       return FALSE;
 
-    if (!gst_va_base_enc_add_hrd_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_hrd_parameter (base, frame->base.picture,
             self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
       return FALSE;
 
-    if (!gst_va_base_enc_add_trellis_parameter (base, frame->picture,
+    if (!gst_va_base_enc_add_trellis_parameter (base, frame->base.picture,
             self->features.use_trellis))
       return FALSE;
 
@@ -2031,7 +2031,7 @@ _h265_encode_one_frame (GstVaH265Enc * self, GstVideoCodecFrame * gst_frame)
           negative_pocs, num_negative_pics, positive_pocs, num_positive_pics))
     return FALSE;
 
-  if (!gst_va_encoder_encode (base->encoder, frame->picture)) {
+  if (!gst_va_encoder_encode (base->encoder, frame->base.picture)) {
     GST_ERROR_OBJECT (self, "Encode frame error");
     return FALSE;
   }
@@ -2400,11 +2400,11 @@ gst_va_h265_enc_encode_frame (GstVaBaseEnc * base,
   frame = _enc_frame (gst_frame);
   frame->last_frame = is_last;
 
-  g_assert (frame->picture == NULL);
-  frame->picture = gst_va_encode_picture_new (base->encoder,
+  g_assert (frame->base.picture == NULL);
+  frame->base.picture = gst_va_encode_picture_new (base->encoder,
       gst_frame->input_buffer);
 
-  if (!frame->picture) {
+  if (!frame->base.picture) {
     GST_ERROR_OBJECT (base, "Failed to create the encode picture");
     return GST_FLOW_ERROR;
   }
@@ -4634,7 +4634,7 @@ gst_va_h265_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 
   frame_in = gst_va_h265_enc_frame_new ();
   frame_in->total_frame_count = base->input_frame_count++;
-  gst_video_codec_frame_set_user_data (frame, frame_in,
+  gst_va_set_enc_frame (frame, (GstVaEncFrame *) frame_in,
       gst_va_h265_enc_frame_free);
 
   return TRUE;
@@ -4659,7 +4659,7 @@ gst_va_h265_enc_prepare_output (GstVaBaseEnc * base,
   base->output_frame_count++;
   frame->duration = base->frame_duration;
 
-  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->base.picture);
   if (!buf) {
     GST_ERROR_OBJECT (base, "Failed to create output buffer");
     return FALSE;
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvajpegenc.c b/subprojects/gst-plugins-bad/sys/va/gstvajpegenc.c
index 80da6e1312..890e375ac2 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvajpegenc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvajpegenc.c
@@ -123,7 +123,7 @@ struct _GstVaJpegEnc
 
 struct _GstVaJpegEncFrame
 {
-  GstVaEncodePicture *picture;
+  GstVaEncFrame base;
 
   /* The total frame count we handled. */
   guint total_frame_count;
@@ -136,7 +136,7 @@ gst_va_jpeg_enc_frame_new (void)
 
   frame = g_slice_new (GstVaJpegEncFrame);
   frame->total_frame_count = 0;
-  frame->picture = NULL;
+  frame->base.picture = NULL;
 
   return frame;
 }
@@ -145,7 +145,7 @@ static void
 gst_va_jpeg_enc_frame_free (gpointer pframe)
 {
   GstVaJpegEncFrame *frame = pframe;
-  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_clear_pointer (&frame->base.picture, gst_va_encode_picture_free);
   g_slice_free (GstVaJpegEncFrame, frame);
 }
 
@@ -156,7 +156,7 @@ gst_va_jpeg_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 
   frame_in = gst_va_jpeg_enc_frame_new ();
   frame_in->total_frame_count = base->input_frame_count++;
-  gst_video_codec_frame_set_user_data (frame, frame_in,
+  gst_va_set_enc_frame (frame, (GstVaEncFrame *) frame_in,
       gst_va_jpeg_enc_frame_free);
 
   return TRUE;
@@ -165,9 +165,7 @@ gst_va_jpeg_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 static inline GstVaJpegEncFrame *
 _enc_frame (GstVideoCodecFrame * frame)
 {
-  GstVaJpegEncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
-  g_assert (enc_frame);
-  return enc_frame;
+  return gst_va_get_enc_frame (frame);
 }
 
 static gboolean
@@ -458,10 +456,10 @@ _jpeg_fill_picture (GstVaJpegEnc * self, GstVaJpegEncFrame * frame,
   /* *INDENT-OFF* */
   *pic_param = (VAEncPictureParameterBufferJPEG) {
     .reconstructed_picture =
-        gst_va_encode_picture_get_reconstruct_surface (frame->picture),
+        gst_va_encode_picture_get_reconstruct_surface (frame->base.picture),
     .picture_width = base->width,
     .picture_height = base->height,
-    .coded_buf = frame->picture->coded_buffer,
+    .coded_buf = frame->base.picture->coded_buffer,
     /* Profile = Baseline */
     .pic_flags.bits.profile = 0,
     /* Sequential encoding */
@@ -492,7 +490,7 @@ _jpeg_add_picture_parameter (GstVaJpegEnc * self, GstVaJpegEncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncPictureParameterBufferType, pic_param,
           sizeof (VAEncPictureParameterBufferJPEG))) {
     GST_ERROR_OBJECT (self, "Failed to create the picture parameter");
@@ -588,7 +586,7 @@ _jpeg_add_quantization_table (GstVaJpegEnc * self, GstVaJpegEncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAQMatrixBufferType, q_matrix, sizeof (VAQMatrixBufferJPEG))) {
     GST_ERROR_OBJECT (self, "Failed to create the quantization table");
     return FALSE;
@@ -641,7 +639,7 @@ _jpeg_add_huffman_table (GstVaJpegEnc * self, GstVaJpegEncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAHuffmanTableBufferType, huffman_table,
           sizeof (VAHuffmanTableBufferJPEGBaseline))) {
     GST_ERROR_OBJECT (self, "Failed to create the huffman table");
@@ -679,7 +677,7 @@ _jpeg_add_slice_parameter (GstVaJpegEnc * self, GstVaJpegEncFrame * frame,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
 
-  if (!gst_va_encoder_add_param (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, frame->base.picture,
           VAEncSliceParameterBufferType, slice_param,
           sizeof (VAEncSliceParameterBufferJPEG))) {
     GST_ERROR_OBJECT (self, "Failed to create the slice parameter");
@@ -795,7 +793,7 @@ _jpeg_create_and_add_packed_segments (GstVaJpegEnc * self,
 
   offset += size;
 
-  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->base.picture,
           VAEncPackedHeaderRawData, data, offset * 8, FALSE)) {
     GST_ERROR_OBJECT (self, "Failed to add packed segment data");
     return FALSE;
@@ -840,7 +838,7 @@ _jpeg_encode_one_frame (GstVaJpegEnc * self, GstVideoCodecFrame * gst_frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_encode (base->encoder, frame->picture)) {
+  if (!gst_va_encoder_encode (base->encoder, frame->base.picture)) {
     GST_ERROR_OBJECT (self, "Encode frame error");
     return FALSE;
   }
@@ -857,11 +855,11 @@ gst_va_jpeg_enc_encode_frame (GstVaBaseEnc * base,
 
   frame = _enc_frame (gst_frame);
 
-  g_assert (frame->picture == NULL);
-  frame->picture = gst_va_encode_picture_new (base->encoder,
+  g_assert (frame->base.picture == NULL);
+  frame->base.picture = gst_va_encode_picture_new (base->encoder,
       gst_frame->input_buffer);
 
-  if (!frame->picture) {
+  if (!frame->base.picture) {
     GST_ERROR_OBJECT (self, "Failed to create the encode picture");
     return GST_FLOW_ERROR;
   }
@@ -892,7 +890,7 @@ gst_va_jpeg_enc_prepare_output (GstVaBaseEnc * base,
   frame->duration = base->frame_duration;
   base->output_frame_count++;
 
-  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->base.picture);
   if (!buf) {
     GST_ERROR_OBJECT (base, "Failed to create output buffer");
     return FALSE;
diff --git a/subprojects/gst-plugins-bad/sys/va/gstvavp9enc.c b/subprojects/gst-plugins-bad/sys/va/gstvavp9enc.c
index d65111dcba..ff32b9c562 100644
--- a/subprojects/gst-plugins-bad/sys/va/gstvavp9enc.c
+++ b/subprojects/gst-plugins-bad/sys/va/gstvavp9enc.c
@@ -152,7 +152,7 @@ struct _GstVaVp9GFGroup
 
 struct _GstVaVp9EncFrame
 {
-  GstVaEncodePicture *picture;
+  GstVaEncFrame base;
   GstVp9FrameType type;
   /* VP9 does not define a frame number.
      This is a virtual number after the key frame. */
@@ -265,7 +265,7 @@ gst_va_vp9_enc_frame_new (void)
   frame = g_slice_new (GstVaVp9EncFrame);
   frame->frame_num = -1;
   frame->type = FRAME_TYPE_INVALID;
-  frame->picture = NULL;
+  frame->base.picture = NULL;
   frame->total_frame_count = 0;
   frame->pyramid_level = 0;
   frame->flags = 0;
@@ -283,7 +283,7 @@ gst_va_vp9_enc_frame_free (gpointer pframe)
 {
   GstVaVp9EncFrame *frame = pframe;
 
-  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_clear_pointer (&frame->base.picture, gst_va_encode_picture_free);
   g_slice_free (GstVaVp9EncFrame, frame);
 }
 
@@ -294,7 +294,7 @@ gst_va_vp9_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 
   frame_in = gst_va_vp9_enc_frame_new ();
   frame_in->total_frame_count = base->input_frame_count++;
-  gst_video_codec_frame_set_user_data (frame, frame_in,
+  gst_va_set_enc_frame (frame, (GstVaEncFrame *) frame_in,
       gst_va_vp9_enc_frame_free);
 
   return TRUE;
@@ -303,11 +303,7 @@ gst_va_vp9_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 static inline GstVaVp9EncFrame *
 _enc_frame (GstVideoCodecFrame * frame)
 {
-  GstVaVp9EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
-
-  g_assert (enc_frame);
-
-  return enc_frame;
+  return gst_va_get_enc_frame (frame);
 }
 
 #ifndef GST_DISABLE_GST_DEBUG
@@ -2217,10 +2213,10 @@ _vp9_fill_frame_param (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame,
     .frame_width_dst = base->width,
     .frame_height_dst = base->height,
     .reconstructed_frame =
-        gst_va_encode_picture_get_reconstruct_surface (va_frame->picture),
+        gst_va_encode_picture_get_reconstruct_surface (va_frame->base.picture),
     /* Set it later. */
     .reference_frames = { },
-    .coded_buf = va_frame->picture->coded_buffer,
+    .coded_buf = va_frame->base.picture->coded_buffer,
     .ref_flags.bits = {
       .force_kf = 0,
       /* Set all the refs later if inter frame. */
@@ -2287,7 +2283,7 @@ _vp9_fill_frame_param (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame,
 
       pic_param->reference_frames[i] =
           gst_va_encode_picture_get_reconstruct_surface
-          (_enc_frame (self->gop.ref_list[i])->picture);
+          (_enc_frame (self->gop.ref_list[i])->base.picture);
 
     }
 
@@ -2323,13 +2319,13 @@ _vp9_encode_one_frame (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame)
     return FALSE;
   }
 
-  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->base.picture,
           VAEncPictureParameterBufferType, &pic_param, sizeof (pic_param))) {
     GST_ERROR_OBJECT (self, "Failed to create the frame parameter");
     return FALSE;
   }
 
-  if (!gst_va_encoder_encode (base->encoder, va_frame->picture)) {
+  if (!gst_va_encoder_encode (base->encoder, va_frame->base.picture)) {
     GST_ERROR_OBJECT (self, "Encode frame error");
     return FALSE;
   }
@@ -2399,33 +2395,35 @@ gst_va_vp9_enc_encode_frame (GstVaBaseEnc * base,
     g_assert (va_frame->flags & FRAME_FLAG_ALREADY_ENCODED);
     _vp9_add_repeat_frame_header (self, va_frame);
   } else {
-    g_assert (va_frame->picture == NULL);
-    va_frame->picture = gst_va_encode_picture_new (base->encoder,
+    g_assert (va_frame->base.picture == NULL);
+    va_frame->base.picture = gst_va_encode_picture_new (base->encoder,
         gst_frame->input_buffer);
 
     _vp9_find_ref_to_update (base, gst_frame);
 
     /* Repeat the sequence for each key. */
     if (va_frame->frame_num == 0) {
-      if (!gst_va_base_enc_add_rate_control_parameter (base, va_frame->picture,
+      if (!gst_va_base_enc_add_rate_control_parameter (base,
+              va_frame->base.picture,
               self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
               self->rc.target_percentage, self->rc.base_qindex,
               self->rc.min_qindex, self->rc.max_qindex, self->rc.mbbrc))
         return FALSE;
 
-      if (!gst_va_base_enc_add_quality_level_parameter (base, va_frame->picture,
-              self->rc.target_usage))
+      if (!gst_va_base_enc_add_quality_level_parameter (base,
+              va_frame->base.picture, self->rc.target_usage))
         return FALSE;
 
-      if (!gst_va_base_enc_add_frame_rate_parameter (base, va_frame->picture))
+      if (!gst_va_base_enc_add_frame_rate_parameter (base,
+              va_frame->base.picture))
         return FALSE;
 
-      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->picture,
+      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->base.picture,
               self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
         return FALSE;
 
       _vp9_fill_sequence_param (self, &seq_param);
-      if (!_vp9_add_sequence_param (self, va_frame->picture, &seq_param))
+      if (!_vp9_add_sequence_param (self, va_frame->base.picture, &seq_param))
         return FALSE;
     }
 
@@ -2471,7 +2469,7 @@ _vp9_create_super_frame_output_buffer (GstVaVp9Enc * self,
     frame_enc = _enc_frame (self->frames_in_super[num]);
 
     frame_size[num] = gst_va_base_enc_copy_output_data (base,
-        frame_enc->picture, data + offset, total_sz - offset);
+        frame_enc->base.picture, data + offset, total_sz - offset);
     if (frame_size[num] <= 0) {
       GST_ERROR_OBJECT (self, "Fails to copy the output data of "
           "system_frame_number %d, frame_num: %d",
@@ -2485,7 +2483,7 @@ _vp9_create_super_frame_output_buffer (GstVaVp9Enc * self,
 
   frame_enc = _enc_frame (last_frame);
   frame_size[num] = gst_va_base_enc_copy_output_data (base,
-      frame_enc->picture, data + offset, total_sz - offset);
+      frame_enc->base.picture, data + offset, total_sz - offset);
   if (frame_size[num] <= 0) {
     GST_ERROR_OBJECT (self, "Fails to copy the output data of "
         "system_frame_number %d, frame_num: %d",
@@ -2599,7 +2597,8 @@ gst_va_vp9_enc_prepare_output (GstVaBaseEnc * base,
     if (self->frames_in_super_num > 0) {
       buf = _vp9_create_super_frame_output_buffer (self, frame);
     } else {
-      buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+      buf = gst_va_base_enc_create_output_buffer (base,
+          frame_enc->base.picture);
     }
     if (!buf) {
       GST_ERROR_OBJECT (base, "Failed to create output buffer%s",
-- 
2.25.1

